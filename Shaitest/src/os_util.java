public class os_util {

//Import standard librariesimport java.io.*;import java.util.*;import java.math.*;//Import SQL and connection librariesimport oracle.jdbc.*;import oracle.sql.*;import java.sql.*;import java.awt.*;import javax.swing.*;//Import APACHE common libraries//import org.apache.commons.vfs.*;//The OS_UTIL classpublic class os_util implements SQLData {  public static long upload_counter;  public static long download_counter;  private byte[] readPrivateKeyFromFile(String filename){ // byte[] byteArray = new byte[] {87, 79, 87, 46, 46, 46}; // FileWriter f = new RandomAccessFile(fileName, "r");  File file = new File(filename);  byte[] data = new byte[(int) file.length()];  try {    new FileInputStream(file).read(data);  } catch (Exception e) {    e.printStackTrace();} //  f.read(b);  return  data;  }//----------------------------------------------------  //Implementation of the abstract methods of SQLData  /*In order to be able to implement the oracle.sql methods we  MUST implement the SQLData java class. There is no meaning in  the variables defined to implement SQLData. It is just one possible  implementation that allows us to have full access to the oracle.sql.*  library.  */  public int id;  public int age;  private String sql_type = "person_t";  public String getSQLTypeName()  {    return sql_type;  }  public void readSQL (SQLInput stream, String type) throws SQLException  {    sql_type = type;    id = stream.readInt();    age = stream.readInt();  }  public void writeSQL (SQLOutput stream) throws SQLException  {    stream.writeInt(id);    stream.writeInt(age);  }  public String toString()  {    String s = "person:";    s += "id: " + id + "\n";    s += "     age: " + age + "\n";    return s;  }  //------------------------------------  /*The following method "executeCommand " allows a user with granted privileges    to execute a general string from Oracle as a UNIX shell command.    The shell's stdout/stderr are then returned as a single clob to Oracle*/    public static oracle.sql.CLOB executeCommand (String command, String error_flag) throws SQLException {    String response = "";    ProcessBuilder pb = new ProcessBuilder("/bin/bash", "-c","export PATH=$ORACLE_HOME/bin:$HOME/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin && "+ command);    pb.redirectErrorStream(true);    try {        Process shell = pb.start();        // Default option, like before, it DOES NOT print the error stream!        if (error_flag.equals("F")) {        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();        // Option "E" - Only error stream in the output        } else if (error_flag.equals("E")) {        InputStream shellIn = shell.getErrorStream();        response = convertStreamToStr(shellIn);        shellIn.close();        // Option "B" - Both outputs concatenated        } else if (error_flag.equals("B")) {        InputStream shellIn = shell.getInputStream();        InputStream errorIn = shell.getErrorStream();        response = convertStreamToStr(shellIn) + convertStreamToStr(errorIn);        shellIn.close();        errorIn.close();        }    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: "          + e.getMessage());    } /*---------------------------------------------------------------------- /* //Uncomment this try statement to output a file on the specified path    try{      // Create file      FileWriter fstream = new FileWriter("/datahub/testJavaCommand.txt");      BufferedWriter out = new BufferedWriter(fstream);      out.write(response);      //Close the output stream      out.close();    }catch (Exception e){      System.err.println("Error: " + e.getMessage());    }*///------------------------------------------------------------------------    Connection con = DriverManager.getConnection("jdbc:default:connection:");    CLOB tempClob = oracle.sql.CLOB.createTemporary(
    con,true,oracle.sql.CLOB.DURATION_CALL);    ((oracle.sql.CLOB)tempClob).

    putString(1,response);    con.close();    return tempClob;
}

    // We need a default option "F", so this function is giving us that.
    public static oracle.sql.CLOB executeCommand(String command) throws SQLException {
        return executeCommand(command, "F");
    }
// Like above, but the return type is
STRUCT public static oracle.sql.STRUCT executeCommand_struct(String command)throws SQLException{String output_response="";
        String error_response="";
        ProcessBuilder pb=new ProcessBuilder("/bin/bash","-c","export PATH=$ORACLE_HOME/bin:$HOME/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin && "+command);pb.redirectErrorStream(true);try{Process shell=pb.start();InputStream shellIn=shell.getInputStream();output_response=convertStreamToStr(shellIn);InputStream errorIn=shell.getErrorStream();error_response=convertStreamToStr(errorIn);shellIn.close();errorIn.close();}catch(IOException e){System.out.println("Error occured while executing Linux command. Error Description: "+e.getMessage());} /*---------------------------------------------------------------------- /* //Uncomment this try statement to output a file on the specified path    try{      // Create file      FileWriter fstream = new FileWriter("/datahub/testJavaCommand.txt");      BufferedWriter out = new BufferedWriter(fstream);      out.write(response);      //Close the output stream      out.close();    }catch (Exception e){      System.err.println("Error: " + e.getMessage());    }*///------------------------------------------------------------------------    Connection con = DriverManager.getConnection("jdbc:default:connection:");    StructDescriptor structdesc = StructDescriptor.createDescriptor("T_STREAM_RESPONSE", con);    CLOB out_tempClob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);    CLOB err_tempClob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);    ((oracle.sql.CLOB)out_tempClob).putString(1,output_response);    ((oracle.sql.CLOB)err_tempClob).putString(1,error_response);    Object[] attributes = {out_tempClob, err_tempClob};    STRUCT struct = new STRUCT(structdesc, con, attributes);    con.close();    return struct;  }  public static oracle.sql.CLOB UnzipFile(String filepath, String filename, String password, String destfilepath) throws SQLException {    String response = "";    ProcessBuilder pb;    if (password.equals("none")){       if (destfilepath.equals("none")){          // when destfilepath is none then the dest file path is the source file path          pb = new ProcessBuilder("/usr/bin/unzip", "-o","-DD", filepath+filename, "-d", filepath);       }       else       {  // destfilepath is not none          pb = new ProcessBuilder("/usr/bin/unzip", "-o","-DD", filepath+filename, "-d", destfilepath);       }    }    else    {  //password is not none       if (destfilepath.equals("none")){          // when destfilepath is none then the dest file path is the source file path          pb = new ProcessBuilder("/usr/bin/unzip", "-o","-DD", "-P", password, filepath+filename, "-d", filepath);       }       else       {  // destfilepath is not none          pb = new ProcessBuilder("/usr/bin/unzip", "-o","-DD", "-P", password, filepath+filename, "-d", destfilepath);       }    }    pb.redirectErrorStream(true);    try {        Process shell = pb.start();        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: " + e.getMessage());    }    Connection con = DriverManager.getConnection("jdbc:default:connection:");    CLOB tempClob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DU
        RATION_CALL);((oracle.sql.CLOB)tempClob).putString(1,response);con.close();return tempClob;}public static oracle.sql.CLOB UngzipFile(String filepath,String filename)throws SQLException{String response="";ProcessBuilder pb;pb=new ProcessBuilder("/usr/bin/gzip","-d",filepath+filename);pb.redirectErrorStream(true);try{Process shell=pb.start();        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: " + e.getMessage());    }    Connection con = DriverManager.getConnection("jdbc:default:connection:");    CLOB tempClob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);    ((oracle.sql.CLOB)tempClob).putString(1,response);    con.close();    return tempClob;  }   public static oracle.sql.CLOB Un7zipFile(String filepath, String filename, String password, String destfilepath) throws SQLException {    String response = "";    ProcessBuilder pb;    if (password.equals("none")){       if (destfilepath.equals("none")){          // when destfilepath is none then the dest file path is the source file path          pb = new ProcessBuilder("/usr/bin/7z", "e", filepath+filename, "-o"+ filepath,"-aoa");       }       else       {  // destfilepath is not none          pb = new ProcessBuilder("/usr/bin/7z", "e", filepath+filename, "-o"+ destfilepath,"-aoa");       }    }    else    {  //password is not none       if (destfilepath.equals("none")){          // when destfilepath is none then the dest file path is the source file path          pb = new ProcessBuilder("/usr/bin/7z", "e", "-p"+ password, filepath+filename, "-o"+ filepath,"-aoa");       }       else       {  // destfilepath is not none          pb = new ProcessBuilder("/usr/bin/7z", "e", "-p"+ password, filepath+filename, "-o"+ destfilepath, "-aoa");          System.out.println(pb.command());       }    }    pb.redirectErrorStream(true);    try {        Process shell = pb.start();        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: " + e.getMessage());    }    Connection con = DriverManager.getConnection("jdbc:default:connection:");    CLOB tempClob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);    ((oracle.sql.CLOB)tempClob).putString(1,response);    con.close();    return tempClob;  }  public static oracle.sql.CLOB UntarFile(String filepath, String filename, String destfilepath) throws SQLException {    String response = "";    ProcessBuilder pb;  //had to export the path in order for tar to work as expected  if (destfilepath.equals("none")){          // when destfilepath is none then the dest file path is the source file path          pb = new  ProcessBuilder("/bin/bash", "-c","export PATH=$ORACLE_HOME/bin:$HOME/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin && tar xmvf "+filepath+filename+" -C "+filepath);       }       else       {  // destfilepath is not none           pb = new  ProcessBuilder("/bin/bash", "-c","export PATH=$ORACLE_HOME/bin:$HOME/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin && tar xmvf "+filepath+filename+" -C "+destfilepath);       }    pb.redirectErrorStream(true);    try {        Process shell = pb.start();        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: " + e.getMessage());    }    Connection con = DriverManager.getConnection("jdbc:default:connection:");    CLO
        B tempClob=oracle.sql.CLOB.createTemporary(con,true,oracle.sql.CLOB.DURATION_CALL);((oracle.sql.CLOB)tempClob).putString(1,response);con.close();return tempClob;}//-------------------------------------------------------------/*Just like the previous method but returns a Java String instead of an oracle.sql.CLOB*/public static String  executeString(String command) throws IOException {    String response = "";    ProcessBuilder pb = new ProcessBuilder("/bin/bash", "-c", "export PATH=$ORACLE_HOME/bin:$HOME/bin:/usr/bin:/bin:/usr/bin/X11:/usr/X11R6/bin && "+command);    pb.redirectErrorStream(true);    try {        Process shell = pb.start();        // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: "          + e.getMessage());    }    return response;  }//------------------------------------------------------------ public static oracle.sql.CLOB executeCommand(oracle.sql.ARRAY file_array) throws java.sql.SQLException, IOException{  String[] file_list = (String[])file_array.getArray();  StringBuffer strBuf = new StringBuffer();  Connection con = DriverManager.getConnection("jdbc:default:connection:");  CLOB  verbose_output = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);try{   for( int i = 0; i < file_array.length(); i++ ){ //loops over the list of files    String response = "";    ProcessBuilder pb = new ProcessBuilder("/bin/bash", "-c"," "+file_list[i]);    pb.redirectErrorStream(true);    Process shell = pb.start();   // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        strBuf.append(response);        shellIn.close();    }   } catch (java.sql.SQLException e) {     e.printStackTrace();    }    ((oracle.sql.CLOB)verbose_output).setString(1, strBuf.toString());  return verbose_output; }//------------------------------------------------------------- public static ProcessBuilder start_shell() throws IOException{  ProcessBuilder pb = new ProcessBuilder("/bin/bash");  pb.redirectErrorStream(true);  return pb; } public static String Test_shell(ProcessBuilder shell) throws IOException{  String response = "";  String s= "/bin/ls -lsa";  /*  OutputStream os;    DataOutputStream out = new DataOutputStream(newBufferedOutputStream(process.getOutputStream()));out.write(s.getBytes());out.flush();      BufferedWriter writer = new BufferedWriter(                  new OutputStreamWriter(os));            writer.write(s);            writer.flush();            writer.close();*/     //BufferedReader isr = new BufferedReader(IOUtils.toInputStream("/bin/ls -lsa"));    // strBuf.append("/bin/ls -lsa");    /*     int i = 0        while(i < t1.size()) {          System.out.println(t1.get(i));          i++;        }    */ /*   OutputStream out = child.getOutputStream();    out.write("some text".getBytes());    out.close();*/    List <String> t1 = shell.command();    try {        Process child = shell.start();        String command = " /bin/ls -lsa ";        //Process child = Runtime.getRuntime().exec(command);       // OutputStream shellOut = bash.getOutputStream();        OutputStream shellOut = child.getOutputStream();        shellOut.write(command.getBytes());        shellOut.flush();        shellOut.close();        // Captures output from the shell        //InputStream shellIn = bash.getInputStream();        InputStream shellIn = child.getInputStream();        response = convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: "          + e.getMessage());    }     try {        Process child = shell.start();        String command = " /usr/bin/who ";        //Process child = Runtime
        iles String response="";ProcessBuilder pb=new ProcessBuilder("/bin/bash","-c"," /bin/rm -vf "+file_list[i]);   // ProcessBuilder pb = new ProcessBuilder("/bin/bash", "-c", " /bin/echo "+file_list[i]);    pb.redirectErrorStream(true);    Process shell = pb.start();   // Captures output from the shell        InputStream shellIn = shell.getInputStream();        response = convertStreamToStr(shellIn);        strBuf.append(response);        shellIn.close();    }   } catch (java.sql.SQLException e) {     e.printStackTrace();    }    ((oracle.sql.CLOB)verbose_output).setString(1, strBuf.toString());  return verbose_output; } //------------------------------------------------------------public static oracle.sql.BLOB getBlobfromFile(String pFilePath) throws IOException,SQLException{ Connection con = DriverManager.getConnection("jdbc:default:connection:"); BLOB  temp_blob = oracle.sql.BLOB.createTemporary(con, true, oracle.sql.BLOB.DURATION_CALL); InputStream inBuffer =new FileInputStream(pFilePath); OutputStream outBuffer = temp_blob.setBinaryStream(1L);            byte[] readBuff = new byte[4096];            int readLen = -1;            //Read the file content and write it to the OutputStream            while ((readLen = inBuffer.read(readBuff)) != -1) {                outBuffer.write(readBuff, 0, readLen);                 }       outBuffer.close();       inBuffer.close(); return temp_blob;}//-------------------------------------------------------------public static oracle.sql.CLOB getClobfromFile(String pFilePath) throws IOException,SQLException{ Connection con = DriverManager.getConnection("jdbc:default:connection:"); CLOB  temp_clob = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL); BufferedReader inBuffer =new BufferedReader(new FileReader(pFilePath)); Writer outBuffer = temp_clob.setCharacterStream(1);            char[] readBuff = new char[4096];            int readLen = -1;            //Read the file content and write it to the OutputStream            while ((readLen = inBuffer.read(readBuff)) != -1) {                outBuffer.write(readBuff, 0, readLen);                 }       outBuffer.close();       inBuffer.close(); return temp_clob;}//Test function to show the properties of a generic collection (PRIVATE) private static String show_info( oracle.sql.ARRAY collection_in ) throws SQLException{    return ( "Array is of length    " +  collection_in.length() +" \n "+ "Array is of type      " +                         collection_in.getSQLTypeName()+ " \n ");}//-------------------------------------------/*Te following method "convertStreamToStr" takes the stdout/stderr stream as retrievedfrom the UNIX shell and converts it to a String object. It is used throughout the classmainly to write the output clob.*/  public static String convertStreamToStr(InputStream is) throws IOException {    if (is != null) {      Writer writer = new StringWriter();      char[] buffer = new char[1024];      try {        Reader reader = new BufferedReader(new InputStreamReader(is,            "UTF-8"));        int n;        while ((n = reader.read(buffer)) != -1) {          writer.write(buffer, 0, n);        }      } finally {        is.close();      }      return writer.toString();    }    else {      return "";    }  }}
        .getRuntime().exec(command);       // OutputStream shellOut = bash.getOutputStream();        OutputStream shellOut = child.getOutputStream();        shellOut.write(command.getBytes());        shellOut.flush();        shellOut.close();        // Captures output from the shell        //InputStream shellIn = bash.getInputStream();        InputStream shellIn = child.getInputStream();        response += convertStreamToStr(shellIn);        shellIn.close();  //------------------------------------  /* FileSystemOptions fsOptions = new FileSystemOptions();   SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking(fsOptions, "no");FileSystemManager fsManager = VFS.getManager();String uri = "sftp://user:password@host:port/absolute-path";FileObject fo = fsManager.resolveFile(uri, fsOptions);*/     // Locate the Jar file//FileSystemManager fsManager = VFS.getManager();//FileObject jarFile = fsManager.resolveFile( "jar:lib/aJarFile.jar" );// List the children of the Jar file/*FileObject[] children = jarFile.getChildren();System.out.println( "Children of " + jarFile.getName().getURI() );for ( int i = 0; i < children.length; i++ ){    System.out.println( children[ i ].getName().getBaseName() );}     *///--------------------    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: "          + e.getMessage());    }    response+=Test_shell2(shell);       return  t1.get(0)/* + t1.get(1)*/ + response;  //  return response; } public static String Test_shell2(ProcessBuilder shell) throws IOException{    String response = "";   try {        Process child = shell.start();        String command = " /usr/bin/top -b -i -n 1 ";        //Process child = Runtime.getRuntime().exec(command);       // OutputStream shellOut = bash.getOutputStream();        OutputStream shellOut = child.getOutputStream();        shellOut.write(command.getBytes());        shellOut.flush();        shellOut.close();        // Captures output from the shell        //InputStream shellIn = bash.getInputStream();        InputStream shellIn = child.getInputStream();        response += convertStreamToStr(shellIn);        shellIn.close();    }    catch (IOException e) {      System.out.println("Error occured while executing Linux command. Error Description: "          + e.getMessage());    }    return response; } /* public static String test_chain() throws IOException{     String host=null;     String verbose_out="";     try{      verbose_out =  sftp_test(host);     } catch (JSchException e) {                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.            } catch (SftpException e) {                e.printStackTrace();            }     finally{     return Test_shell(start_shell()) +" Vector size: "+ num;} }  */ //--------------------------------------- public static String convertClob2String(oracle.sql.CLOB clobInData) { String stringClob = null;  try {    long i = 1;        int clobLength = (int) clobInData.length();        stringClob = clobInData.getSubString(i, clobLength);     }   catch (Exception e) {          System.out.println(e);     }   return stringClob;  } //----------------------------------------------------------------- /* This method accepts a list of files passed as an oracle collection (an array or a varchar2-type column of a table) and sequentially runs a "rm -vf" over the sequence. The stdout/stderr of the unix shell is then returned to oracle as a single oracle.sql.CLOB object. */ public static oracle.sql.CLOB cleanData(oracle.sql.ARRAY file_array) throws java.sql.SQLException, IOException{  String[] file_list = (String[])file_array.getArray();  StringBuffer strBuf = new StringBuffer();  Connection con = DriverManager.getConnection("jdbc:default:connection:");  CLOB  verbose_output = oracle.sql.CLOB.createTemporary(con, true, oracle.sql.CLOB.DURATION_CALL);try{   for( int i = 0; i < file_array.length(); i++ ){ //loops over the list of f


        }
